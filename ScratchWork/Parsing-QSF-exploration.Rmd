---
title: "QSF Parsing Exercise"
author: "Emma Morgan"
date: "2/24/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(QualtricsTools)
```

## Parsing the QSF

This is an exploration of trying to improve the ways in which we parse the QSF for the QualtricsTools project. Emma will work on this as she is able. This is being done with a markdown document to try and get a little more familiar with markdown and make notes as I go along.

Start by loading the QSF and CSV from the sample survey as a test


```{r setpath}
qsf_sample <- here::here("data","Sample Surveys", "Long Exhaustive Sample Survey","Long_Exhaustive_Sample_Survey.qsf")
csv_sample <- here::here("data","Sample Surveys", "Long Exhaustive Sample Survey","Long_Exhaustive_Sample_Survey.csv")
```

The csv should not be necessary at this time and the goal is to do most things without it. To start, read in the QSF JSON and assign to variable "survey".

```{r readsurvey}
survey_sample <- rjson::fromJSON(file=qsf_sample)
```

The function blocks_from_survey pulls the "Survey Blocks" element from the json file. This creates placeholders for all of the survey elements. This could be done using purrr instead of the Filter function. 

First step should be to go through and name each list item of survey elements based on the primary attribute. This will be much cleaner and easier to use since currently the items are unnamed. This should give us the QIDs for questions that we need, the information we need for Survey Blocks, Survey Flow, Survey Options, and the default response set.

The steps are not going to use pipes for now so everything is explicit, but this can be made much easier at a later time.


```{r revise-parse-qsf}
#This is going to use the sample survey, but this could change.
# Read the json survey file in to start
survey_json <- rjson::fromJSON(file=qsf_sample)
#Extract the survey elements from survey
survey_elements_unnamed <- survey_json[["SurveyElements"]]
# Name each item of survey elements based on the primary attribute.
# This includes Survey Blocks, Survey Flow, Survey Options, and QIDs.
# These names should make it much easier for us to get the information we need to extract.
survey_elements <-purrr::set_names(survey_elements_unnamed, map_chr(survey_elements_unnamed, "PrimaryAttribute"))
#Now extract the blocks; this is really the payload element of element "Survey Blocks"
#Replace blocks_from_survey
blocks_all <- purrr::pluck(survey_elements, "Survey Blocks", "Payload") %>%
  #Name the blocks with their descriptive value; this will be more user-friendly
  #Use "." to refer to the piped value within the map_chr function
  purrr::set_names(map_chr(.,"Description"))

trash_questions <- blocks_all %>%
  #Now pluck just the trash block
  pluck("Trash / Unused Questions", "BlockElements") %>%
  #Pull a character vector of only the QIDs for questions that are in the trash
  map_chr(.,"QuestionID")
  

blocks_notrash <- blocks_all %>%
  #Remove trash block based on the "Type" element of the block
  purrr::keep(~ .x[["Type"]]!= "Trash")



#Now we want to extract the list of questions. These can be identified as SurveyElements that have Element "SQ"
#Replaces questions_from_survey
questions <- purrr::keep(survey_elements, ~ .x[["Element"]]=="SQ") %>%
  #Remove questions that are in the trash, as specified by "trash_questions
  discard( ~ .x[["PrimaryAttribute"]] %in% trash_questions)

```


At this point we have created one list of all the questions excluding the ones in the trash, and a second list with the blocks excluding the trash block. The next step in get_setup is to split the side-by-side questions. I'm going to explore to see if we can split these more efficiently and with human readable text instead of trying to use all of the complicated block indexing.

For each question, check if the Question Type is "SBS" for side-by-side

```{r split_sBS_new}

#Keep only the side-by-side questions for this exploration
sbs <- keep(questions, ~.x[["Payload"]][["QuestionType"]]=="SBS") 

sbs_sample <- sbs[[1]]
  #Get just hte Payload for each of these questions, since this is what we actually need

sbs_sample_split <- sbs_sample %>%
  #Pull only the payload
  pluck("Payload") 

#Pull out the additional information from these questions
addlq <- pluck(sbs_sample_split, "AdditionalQuestions") %>%
  #Add names based on the QID
  #There's an issue with the "#" symbol, so replace with underscore in the question name; may need to change this later
  set_names(map_chr(.,~ str_replace(.x[["QuestionID"]], "#","_"))) 

##Need to keep working on this



```

Existing function for splitting side_by_side questions

```{r split_side_by_sides}


{
    for (i in length(questions):1) {
        if (questions[[i]][["Payload"]][["QuestionType"]] == 
            "SBS") {
            split_questions <- list()
            for (j in 1:questions[[i]][["Payload"]][["NumberOfQuestions"]]) {
                split_questions[[j]] <- list()
                split_questions[[j]][["Payload"]] <- questions[[i]][["Payload"]][["AdditionalQuestions"]][[as.character(j)]]
                split_questions[[j]][["Payload"]][["QuestionText"]] <- paste0(clean_html(questions[[i]][["Payload"]][["QuestionText"]]), 
                  "-", clean_html(questions[[i]][["Payload"]][["AdditionalQuestions"]][[as.character(j)]][["QuestionText"]]))
                split_questions[[j]][["qtNotes"]] <- list()
                if ("qtNotes" %in% names(questions[[i]])) 
                  split_questions[[j]][["qtNotes"]] <- questions[[i]][["qtNotes"]]
                split_questions[[j]][["qtNotes"]] <- c(split_questions[[j]][["qtNotes"]], 
                  "This question was split from a side-by-side question.")
            }
            orig_question_id <- questions[[i]][["Payload"]][["QuestionID"]]
            split_question_ids <- lapply(split_questions, function(x) x[["Payload"]][["QuestionID"]])
            split_block_elements <- lapply(split_question_ids, 
                function(x) list(Type = "Question", QuestionID = x))
            for (k in 1:length(blocks)) {
                if ("BlockElements" %in% names(blocks[[k]])) {
                  for (j in 1:length(blocks[[k]][["BlockElements"]])) {
                    block_elmt_question_id <- blocks[[k]][["BlockElements"]][[j]][["QuestionID"]]
                    if (block_elmt_question_id == orig_question_id) {
                      blocks[[k]][["BlockElements"]][[j]] <- NULL
                      blocks[[k]][["BlockElements"]] <- append(blocks[[k]][["BlockElements"]], 
                        split_block_elements, after = (j - 1))
                      break
                    }
                  }
                }
            }
            questions[[i]] <- NULL
            questions <- append(questions, value = split_questions, 
                after = (i - 1))
        }
    }
    return(list(questions, blocks))
}
```


Now I want to try and create a response column dictionary. I'm going to go back to do this using the sample survey

```{r response_column_dictionary}

qsf_sample <- here::here("data","Sample Surveys", "Better Sample Survey","Better_Sample_Survey.qsf")
csv_sample <- here::here("data","Sample Surveys", "Better Sample Survey","Better_Sample_Survey.csv")

survey_json <- rjson::fromJSON(file=qsf_sample)
#Extract the survey elements from survey
survey_elements_unnamed <- survey_json[["SurveyElements"]]

survey_elements <-purrr::set_names(survey_elements_unnamed, map_chr(survey_elements_unnamed, "PrimaryAttribute"))
#Now I want to set up something from the Blocks with the list of questions and their corresponding Block

blocks_use <- survey_elements %>%
  pluck("Survey Blocks", "Payload") %>%
  set_names(map_chr(., "Description"))

#Now trying to make a data frame
qdict <- enframe(blocks_use, name = "Block Name", value = "BlockList") %>%
  #Now we want to expand the BlockList column
  unnest_wider(BlockList) %>%
  unnest_longer(BlockElements) %>%
  
  mutate(ElementType = map_chr(BlockElements, "Type"),
         QID = map_chr(BlockElements, "QuestionID"))

#Now we want to get the question information separately

question_dict <- survey_elements %>%
  keep(~ .x[["Element"]] == "SQ") %>%
  enframe(name = "QID", value = "QuestionList") %>%
  unnest_wider(QuestionList) %>%
  unnest_wider(Payload)

#At this point we have most of the information in a table. There are still lists for choices and recode values and 
#we will need to worry about check all that apply and such, but it is getting closer.



```


## get_reorganized_questions_and_blocks

This is the function we are trying to simplify in some ways

```{r get_reorganized_questions_and_blocks}

get_reorganized_questions_and_blocks <-
  function(survey, responses, original_first_rows) {
    # select the block elements from the survey
    blocks <- blocks_from_survey(survey)

    # select the questions from the survey
    questions <- questions_from_survey(survey)

    # remove the questions that were found in the trash block
    questions <- remove_trash_questions(questions, blocks)

    # remove the trash block from the blocks
    blocks <- remove_trash_blocks(blocks)

    # split side by side questions into their component questions
    questions_and_blocks <- split_side_by_sides(questions, blocks)
    questions <- questions_and_blocks[[1]]
    blocks <- questions_and_blocks[[2]]

    # clean the question text of HTML and CSS tags
    questions <- clean_question_text(questions)

    # categorize each question's Response Type
    # (Single Answer, Multiple Answer,
    #  Text Entry, Rank Order)
    questions <- human_readable_qtype(questions)

    # insert the response columns into their corresponding
    # question under question[['Responses']]
    questions <-
      link_responses_to_questions(questions, responses, original_first_rows)

    # generate each question's results table and insert it
    # in question[['Table']]
    questions <- generate_results(questions, original_first_rows)

    # insert notes into their corresponding questions
    notes <- notes_from_survey(survey)
    questions <- insert_notes_into_questions(questions, notes)

    # insert the questions into the blocks
    blocks <- questions_into_blocks(questions, blocks)

    # insert the header into the blocks
    blocks[['header']] <- c(paste0("Survey Name: ",
                                   survey[['SurveyEntry']][['SurveyName']]),
                            paste0("Number of Respondents: ",
                                   nrow(responses)))

    # return questions and blocks as a list of 2 elements
    questions_and_blocks <- list()
    questions_and_blocks[['questions']] <- questions
    questions_and_blocks[['blocks']] <- blocks
    return(questions_and_blocks)
  }
```


```{r remove_trash_blocks}
function (blocks) 
{
    for (i in number_of_blocks(blocks):1) {
        if ("Type" %in% names(blocks[[i]])) {
            if (blocks[[i]][["Type"]] == "Trash") {
                blocks[[i]] <- NULL
                next
            }
        }
        if ("BlockElements" %in% names(blocks[[i]])) {
            if (length(blocks[[i]][["BlockElements"]]) != 
                0) {
                for (j in length(blocks[[i]][["BlockElements"]]):1) {
                  if (blocks[[i]][["BlockElements"]][[j]][["Type"]] != 
                    "Question") {
                    blocks[[i]][["BlockElements"]][[j]] <- NULL
                  }
                }
            }
        }
    }
    return(blocks)
}
```
