---
title: "QSF Parsing Exercise"
author: "Emma Morgan"
date: "2/24/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(QualtricsTools)
```

##Updating functions

This is a space where anything we functionalize new can be added to our environment so that we can work wiht and use it in the later steps.

###Revise extraction of user notes and inserting into questions.

Now we can functionalize how we are creating user notes. This should replace notes_from_survey. We will also want to update how we insert notes into questions above.

```{r note_text_from_survey}

note_text_from_survey <- function(survey) {
  #From the survey, keep elements that have user notes; these are identified from the list of survey elements
  #as those with Elements "NT"
  user_notes_text <- keep(survey[["SurveyElements"]], ~.x[["Element"]]=="NT") %>%
    #Now rename the user notes with their QID based on parent ID instead of the primary attribute
    set_names(map_chr(., ~ .x[["Payload"]][["ParentID"]])) %>%
    #From the notes block payload, pluck "Notes" element
    #Now we want to pull only the next for the user notes
    #But only if the element "Removed" is false
    #First keep only the "Notes" section within Payload, which has the information we need
    map(~ pluck(.x, "Payload","Notes")) %>%
    #only keep notes for which the "Removed" status is FALSE; these are notes that have not been deleted
    map(~ keep(.x, ~ !.x[["Removed"]])) %>%
    #Now we want to pluck only the messages, which is the text of the note
    map(~map(.x, ~pluck(.x,"Message"))) %>%
    map(~ flatten(.x)) %>%
    #Prepend each note with the "User note: " text tag
    map(~map(.x,~stringr::str_c("User note: ",.x)))
  return(user_notes_text)
}
```   


###Notes into Questions

Revise the function that appends a list of questions with the appropriate user notes

```{r insert_notes_into_questions_rv}

insert_notes_into_questions_rv <- function(questions, notes) {
  #For each question, first see if it has corresponding notes.
  #If it does, append the question list with element "qtNotes"
  questions_with_notes <- questions %>%
    purrr::modify_if(~.x[["PrimaryAttribute"]] %in% names(notes),
                     ~ append(.x, list("qtNotes"= pluck(notes,.x[["PrimaryAttribute"]]))))
  return(questions_with_notes)
}

```

###Add a function for determining Qualtrics Type human readable from the Payload information. This is used intially with quesitons, then again when splitting side-by-side questions into their components. Functionalizing this will allow us to more easily add cases for other questino types as we move forward with development and enhancements.

```{r qtype_human}

qtype_human <- function(question) {
  
  QuestionTypeHuman <-  dplyr::case_when(is_multiple_answer(question) ~ "Multiple Answer",
                                         is_single_answer(question) ~ "Single Answer",
                                         is_rank_order(question) ~ "Rank Order",
                                         is_text_entry(question) ~ "Text Entry",
                                         question[["Payload"]][["QuestionType"]]=="SBS" ~ "Side-by-side",
                                         question[["Payload"]][["QuestionType"]]=="DB" ~ "Descriptive Box",
                                         TRUE ~ "Other question type")
  return(QuestionTypeHuman)
  
}


```

###Revise splitting a single side-by-side question

This  function will be iterated over questions. A separate step of get_setup will split blocks based on the list of SBS questions.

```{r split_side_by_side_q}

#This applies to a single side-by-side question
split_side_by_side_q <- function(question) {
  
  #For a SBS question only
  #There should be a chekc earlier that the side-by-side actually has additional questions
  #Assume additional questions here
  split_q <- list()
  
  #We may not actually need this
  mainq <- modify_at(question, "AdditionalQuestions", ~NULL)
  
  #Extract the question text from the main part of the question
  #If we've already run the other parts of the question, this will be the clean question text
    #If not, pull the original question text
  mainq_text <- if_else("QuestionTextClean" %in% names(question),
                        question[["QuestionTextClean"]],
                        question[["Payload"]][["QuestionText"]]) 
  
  main_qid <- mainq[["PrimaryAttribute"]]
  
  
  additional_questions <- question[["Payload"]][["AdditionalQuestions"]] %>%
  #Add names based on the QID
  #There's an issue with the "#" symbol, so replace with underscore in the question name; may need to change this later
    set_names(map_chr(.,~ str_replace(.x[["QuestionID"]], "#","_"))) 
  
  #Now we want to edit the split questions. In the original QualtricsTools, split quesitons ONLY have Payload and qtNotes
    #We will have to decide at a later date if anything else should be included
  
  
  split_q <- additional_questions %>%
    
    #Assign the additional question information as Payload for the new question element
    map(~ list("Payload" = .x)) %>%
    #Pull qtNotes from the original question and append them to each item
    #Add an additional note that this was split from a side-by-side question
    map(~ rlist::list.append(.x,qt_notes = if_else("qtNotes" %in% names(mainq),
                                                   list(append(mainq[["qtNotes"]],
                                                               "This question was split from a side-by-side question.")),
                                                   list("This question was split from a side-by-side question.")))) %>%
    #Add clean question text to the side-by-side question element
    map(~ rlist::list.append(.x, QuestionTextClean = str_c(mainq_text,"---",.x[["Payload"]][["QuestionText"]]))) %>%
    
    #Add QualtricsQtype for the side by side; prepend with "SBS" to indicate this came from a side-by-side question
    map( ~ rlist::list.append(.x, Qualtrics_qtype = paste0("SBS_",.x[["Payload"]][["QuestionType"]]))) %>%
    
    #Add human readable question type
    map(~ rlist::list.append(.x, QuestionTypeHuman = qtype_human(.x))) %>%
    
    #Add Primary Attribute that corresponds to the list element name
    map(~ rlist::list.append(.x, PrimaryAttribute = str_replace(.x[["Payload"]][["QuestionID"]], "#","_"))) %>%
    
    #Add a new element indicating that this was split from a side-by-side question
    map( ~ rlist::list.append(.x, SBS_origQID = main_qid))
    
    
  return(split_q)

}

```


###Splitting side by side questions as part of get_setup

```{r split_sbs_questions}

split_sbs_questions <-  function(questions) {
  #Iterate through the questions
  for (q in questions) {
    #For each side-by-side question
    if(q[["Qualtrics_qtype"]]=="SBS") {
      #Update the list of split questions
      questions <- append(questions,
                          split_side_by_side_q(q), 
                          after=match(q[["PrimaryAttribute"]],names(questions)))
    }
  }
  #Now remove the original side-by-side questions since we no longer need these
  questions <- questions %>%
    discard(~ .x[["Qualtrics_qtype"]]=="SBS")
}

```

###Splitting block elements as part of get_setup

This function iterates through a block and, where appropriate, splits the block element for a side-by-side question into separate elements for each component of the side-by-side.

```{r split_block_elements}
split_block_elements <- function(block,sbs_question_qids) {
  if (! "BlockElements" %in% names(block)) {
    return(block)
  }
  block_elements <- block[["BlockElements"]]
  
  #Create the elements that we will want to split
  sbs_questions <- list()

  for (i in 1:length(sbs_question_qids)) {
    sbs_question_entry <- list(Type = "Question",
                               QuestionID = names(sbs_question_qids)[[i]],
                               ParentID = sbs_question_qids[[i]])
    sbs_questions[[i]] <- sbs_question_entry
  }
  
  for (element in block_elements) {
    #Check that the element has a question ID, then check whether it's in the list
    if ("QuestionID" %in% names(element) && 
        element[["QuestionID"]] %in% map_chr(sbs_questions,"ParentID")) {
      
      qid_orig <- element[["QuestionID"]]
      split_elements <- keep(sbs_questions, ~.x[["ParentID"]]==qid_orig) %>%
        #Now name them with the Question ID
        set_names(paste0(map_chr(., "QuestionID"),"-Question")) %>%
        #And now remove the parent ID element
        map(~rlist::list.remove(.x,"ParentID"))
      
      block_elements <- append(block_elements,
                               split_elements,
                               after = match(element[["QuestionID"]],str_replace(names(block_elements),"-Question$","")))
    }
  }
  
  #And now we want to remove those original question elements
  block_elements <- discard(block_elements, ~.x[["QuestionID"]] %in% sbs_question_qids)
  
  block[["BlockElements"]] <- block_elements
  return(block)
  
}
```

###Skip logic into questions
```{r insert_skiplogic_into_questions}
#Add skip logic to questions
insert_skiplogic_into_questions <- function(questions,blocks) {
  for (b in blocks) {
    if (! "BlockElements" %in% names(b)) {
      return(questions)
    } else {
      for (be in b[["BlockElements"]]) {
        has_skip_logic <- "SkipLogic" %in% names(be)
        if(has_skip_logic) {
          skip_logic <- be[["SkipLogic"]]
          #Add display logic to the question
          questions <- modify_at(questions,be[["QuestionID"]], ~rlist::list.append(.x,SkipLogic = skip_logic))
        }
      }
      return(questions)
    }
  }
}
```

###Insert questions into blocks

```{r insert_questions_into_block}

insert_questions_into_block <- function(block,questions) {
  if ("BlockElements" %in% names(block)) {
    block[["BlockElements"]] <- modify_if(block[["BlockElements"]],
                                           ~.x[["Type"]]=="Question",
                                           ~pluck(questions,.x[["QuestionID"]]))
  }
  return(block)
}

```

###Get reorganized questions and blocks

This is a revised version of the function that is used as the workhorse in get_setup and does a LOT of what is required later on. It will still need to be documented VERY carefully and incorporated more fully into the package.

```{r get_reorganized_questions_and_blocks_rv}
#This is called by get_setup to pull what we need from survey and responses 

get_reorganized_questions_and_blocks_rv <- function(survey,
                                                 responses,
                                                 original_first_rows) {
  #The survey JSON was read in during an early block, so we can just work with this.
  #Extract the survey elements from survey
  survey_elements <- survey_json[["SurveyElements"]] %>%
    # Name each item of survey elements based on the primary attribute.
    # This includes Survey Blocks, Survey Flow, Survey Options, and QIDs.
    # These names should make it much easier for us to get the information we need to extract.
    purrr::set_names(map_chr(., "PrimaryAttribute"))
  
  qtNotesList <- note_text_from_survey(survey_json)
  
  #Now extract the blocks; this is really the payload element of element "Survey Blocks"
  #Replace blocks_from_survey
  blocks_all <- purrr::pluck(survey_elements, "Survey Blocks", "Payload") %>%
    #Name the blocks with their descriptive value; this will be more user-friendly
    #Use "." to refer to the piped value within the map_chr function
    purrr::set_names(map_chr(.,"Description"))
  
  trash_questions <- blocks_all %>%
    #Now pluck just the trash block
    pluck("Trash / Unused Questions", "BlockElements") %>%
    #Pull a character vector of only the QIDs for questions that are in the trash
    map_chr(.,"QuestionID")
  
  
  blocks_notrash <- blocks_all %>%
    #Remove trash block based on the "Type" element of the block
    purrr::keep(~ .x[["Type"]]!= "Trash") %>%
    #Name the BlockElements (quesiton items) within the blocks
    map(~ modify_at(.x, "BlockElements", ~set_names(.x, map_chr(.x, ~ str_c(.x[["QuestionID"]],.x[["Type"]],sep="-")))))
  
  
  #Now we want to extract the list of questions. These can be identified as SurveyElements that have Element "SQ"
  #Replaces questions_from_survey
  questions <- purrr::keep(survey_elements, ~ .x[["Element"]]=="SQ") %>%
    #Remove questions that are in the trash, as specified by "trash_questions
    discard( ~ .x[["PrimaryAttribute"]] %in% trash_questions) %>%
    #Now clean question text using clean_html
    map(~ append(.x,list("QuestionTextClean" = clean_html(.x[["Payload"]][["QuestionText"]])))) %>%
    #Add the Qualtrics question type; this is for reference and won't be used in results
    map(~append(.x, list("Qualtrics_qtype" = .x[["Payload"]][["QuestionType"]]))) %>%
    #Add human readable question type to each question; this can be edited if we want 
    #We will want ot expand this as we keep going
    #We will need to reclassify the question type when we split side-by-side!!
    map(~append(.x,list("QuestionTypeHuman" = qtype_human(.x)))) %>%
    #Now we want to insert notes into questions.
    #Previously side-by-side questions were not getting their notes. 
    #This is now happening before the split to ensure that notes are included
    insert_notes_into_questions_rv(notes = qtNotesList) %>%
    
    #Insert skip logic into the questions
    insert_skiplogic_into_questions(blocks=blocks_notrash) %>%
    
    #Split side-by-side questions into their components
    #We can do this by first appending split side-by-side questions to the list, then removing the originals
    split_sbs_questions() %>%
    
    #Link responses to questions
    link_responses_to_questions(responses = responses,original_first_rows = original_first_rows) %>%
    
    #Generate a results table for each question
    generate_results(original_first_rows = original_first_rows)
  
  #Now get a list of the side-by-side questions 
  #This is a named list where the name is the NEW split question ID and the element is the original QID
  sbs_question_qids<- keep(questions,~"SBS_origQID" %in% names(.x)) %>%
    map("SBS_origQID")
  
  #Revise the blocks to create space for elements split from side-by-side questions
  blocks <- map(blocks_notrash, ~ split_block_elements(.x,sbs_question_qids)) %>%
    #Now insert questions into blocks
    map(~ insert_questions_into_block(block = .x, questions = questions))
  
  return(list("questions" = questions, "blocks" = blocks))
  
}



```


## Parsing the QSF

This is an exploration of trying to improve the ways in which we parse the QSF for the QualtricsTools project. Emma will work on this as she is able. This is being done with a markdown document to try and get a little more familiar with markdown and make notes as I go along.

Start by loading the QSF and CSV from the sample survey as a test


```{r setpath}
qsf_sample <- here::here("ScratchWork","Sample_survey_edits", "Long_Exhaustive_Sample_Survey.qsf")
csv_sample <- here::here("data","Sample Surveys", "Long Exhaustive Sample Survey","Long_Exhaustive_Sample_Survey.csv")
```

```{r setpath_bettersamplesurvey}
qsf_sample <- here::here("data","Sample Surveys", "Better Sample Survey", "Better_Sample_Survey.qsf")
csv_sample <- here::here("data","Sample Surveys", "Better Sample Survey","Better_Sample_Survey.csv")
```

The csv should not be necessary at this time and the goal is to do most things without it. To start, read in the QSF JSON and assign to variable "survey".

```{r readsurvey}
survey_json <- rjson::fromJSON(file=qsf_sample)
responses <- ask_for_csv(csv_sample,headerrows = 3)[[1]]
original_first_rows <- ask_for_csv(csv_sample,headerrows = 3)[[2]]
```

The function blocks_from_survey pulls the "Survey Blocks" element from the json file. This creates placeholders for all of the survey elements. This could be done using purrr instead of the Filter function. 

First step should be to go through and name each list item of survey elements based on the primary attribute. This will be much cleaner and easier to use since currently the items are unnamed. This should give us the QIDs for questions that we need, the information we need for Survey Blocks, Survey Flow, Survey Options, and the default response set.

The steps are not going to use pipes for now so everything is explicit, but this can be made much easier at a later time.

### Revise setup process using purrr and %>%



This is my working version of inserting questions to blocks.

### Creating response column dictionary from QSF

Now I want to try and create a response column dictionary. I'm going to go back to do this using the sample survey

```{r response_column_dictionary}

qsf_sample <- here::here("data","Sample Surveys", "Better Sample Survey","Better_Sample_Survey.qsf")
csv_sample <- here::here("data","Sample Surveys", "Better Sample Survey","Better_Sample_Survey.csv")

survey_json <- rjson::fromJSON(file=qsf_sample)
#Extract the survey elements from survey
survey_elements_unnamed <- survey_json[["SurveyElements"]]

survey_elements <-purrr::set_names(survey_elements_unnamed, map_chr(survey_elements_unnamed, "PrimaryAttribute"))
#Now I want to set up something from the Blocks with the list of questions and their corresponding Block

blocks_use <- survey_elements %>%
  pluck("Survey Blocks", "Payload") %>%
  set_names(map_chr(., "Description"))

#Now trying to make a data frame
qdict <- enframe(blocks_use, name = "Block Name", value = "BlockList") %>%
  #Now we want to expand the BlockList column
  unnest_wider(BlockList) %>%
  unnest_longer(BlockElements) %>%
  
  mutate(ElementType = map_chr(BlockElements, "Type"),
         QID = map_chr(BlockElements, "QuestionID"))

#Now we want to get the question information separately

question_dict <- survey_elements %>%
  keep(~ .x[["Element"]] == "SQ") %>%
  enframe(name = "QID", value = "QuestionList") %>%
  unnest_wider(QuestionList) %>%
  unnest_wider(Payload)

#At this point we have most of the information in a table. There are still lists for choices and recode values and 
#we will need to worry about check all that apply and such, but it is getting closer.



```

### get_setup

The get_setup function is our starting point for QualtricsTools. Understanding and simplifying this will help us to make a better tool and allow more flexibility moving forward.

```{r get_setup}
get_setup <-
  function (qsf_path,
            csv_path,
            headerrows,
            already_loaded,
            return_data_as_list = FALSE,
            sample_data = FALSE)
  {
    if (missing(already_loaded)) {
      already_loaded <- FALSE
    }
    if (already_loaded == FALSE && sample_data == FALSE) {
      if (missing(headerrows)) {
        headerrows <-
          readline(prompt = "Enter the number of response data header rows [Default: 3]: ")
        if (!grepl("^[0-9]+$", headerrows)) {
          cat("Defaulting to headerrows = 3\n")
          headerrows = 3
        }
        else
          headerrows <- as.integer(headerrows)
      }
      if (missing(qsf_path)) {
        survey <- ask_for_qsf()
      }
      else {
        survey <- ask_for_qsf(qsf_path)
      }
      if (missing(csv_path)) {
        capture.output(responses <- ask_for_csv(headerrows = headerrows))
      }
      else {
        capture.output(responses <- ask_for_csv(csv_path,
                                                headerrows = headerrows))
      }
      original_first_rows <- as.data.frame(responses[[2]])
      responses <- as.data.frame(responses[[1]])
    }
    if (already_loaded == TRUE && sample_data == FALSE) {
      if (exists("survey", where = globalenv()) && exists("responses",
                                                          where = globalenv()) && exists("original_first_rows",
                                                                                         where = globalenv())) {
        survey <- get("survey", envir = globalenv())
        responses <- get("responses", envir = globalenv())
        original_first_rows <- get("original_first_rows",
                                   envir = globalenv())
      }
      else
        stop(
          "\nThe necessary objects do not exist in the global scope. Each of survey,\nresponses, and original_first_rows should be in the global scope when\nusing the global scope when using the already_loaded=TRUE parameter.\nUse ask_for_qsf() and ask_for_csv() to get a survey object list from a\nQualtrics Survey File and a pair of dataframes (responses,\noriginal_first_rows) from a survey's CSV response data. Alternatively,\npass the parameters for qsf_path, csv_path, and headerrows, or use the\nsample_survey=TRUE parameter."
        )
    }
    if (sample_data == TRUE) {
      survey <- sample_survey
      responses <- sample_responses
      original_first_rows <- sample_original_first_rows
    }
    questions_and_blocks <-
      get_reorganized_questions_and_blocks(survey,
                                           responses, original_first_rows)
    questions <- questions_and_blocks[[1]]
    blocks <- questions_and_blocks[[2]]
    blocks[["header"]] <- c(paste0("Survey Name: ",
                                   survey[["SurveyEntry"]][["SurveyName"]]),
                            paste0("Number of Respondents: ", nrow(responses)))
    flow <- flow_from_survey(survey)
    if (return_data_as_list) {
      return_vals = list(
        survey = survey,
        responses = responses,
        questions = questions,
        blocks = blocks,
        original_first_rows = original_first_rows,
        flow = flow
      )
      return(return_vals)
    }
    else {
      survey <<- survey
      responses <<- responses
      questions <<- questions
      blocks <<- blocks
      original_first_rows <<- original_first_rows
      flow <<- flow_from_survey(survey)
      if (exists("survey", 1) && exists("responses",
                                        1) && exists("questions", 1) && exists("blocks",
                                                                               1) && exists("original_first_rows")) {
        cat(
          "survey, responses, questions, blocks, original_first_rows,\n        and flow have now been made global objects.\n"
        )
      }
    }
  }
```


### get_reorganized_questions_and_blocks

This is the function we are trying to simplify. In many ways, get_reorganized_questions_and_blocks is the starting workhorse upon which get_setup functions and orients a user to working with QualtricsTools.

```{r get_reorganized_questions_and_blocks}

get_reorganized_questions_and_blocks <-
  function(survey, responses, original_first_rows) {
    # select the block elements from the survey
    blocks <- blocks_from_survey(survey)

    # select the questions from the survey
    questions <- questions_from_survey(survey)

    # remove the questions that were found in the trash block
    questions <- remove_trash_questions(questions, blocks)

    # remove the trash block from the blocks
    blocks <- remove_trash_blocks(blocks)

    # split side by side questions into their component questions
    questions_and_blocks <- split_side_by_sides(questions, blocks)
    questions <- questions_and_blocks[[1]]
    blocks <- questions_and_blocks[[2]]

    # clean the question text of HTML and CSS tags
    questions <- clean_question_text(questions)

    # categorize each question's Response Type
    # (Single Answer, Multiple Answer,
    #  Text Entry, Rank Order)
    questions <- human_readable_qtype(questions)

    # insert the response columns into their corresponding
    # question under question[['Responses']]
    questions <-
      link_responses_to_questions(questions, responses, original_first_rows)

    # generate each question's results table and insert it
    # in question[['Table']]
    questions <- generate_results(questions, original_first_rows)

    # insert notes into their corresponding questions
    notes <- notes_from_survey(survey)
    questions <- insert_notes_into_questions(questions, notes)

    # insert the questions into the blocks
    blocks <- questions_into_blocks(questions, blocks)

    # insert the header into the blocks
    blocks[['header']] <- c(paste0("Survey Name: ",
                                   survey[['SurveyEntry']][['SurveyName']]),
                            paste0("Number of Respondents: ",
                                   nrow(responses)))

    # return questions and blocks as a list of 2 elements
    questions_and_blocks <- list()
    questions_and_blocks[['questions']] <- questions
    questions_and_blocks[['blocks']] <- blocks
    return(questions_and_blocks)
  }
```

Existing function for splitting side_by_side questions. This is for reference currently and should not be run as actual R script.

### split_side_by_sides

```{r split_side_by_sides}
#This is the existing code to create the function splitting side-by-side questions.
#It is included here for reference during the development/revision process.

split_side_by_sides <- function(questions, blocks)
{
  for (i in length(questions):1) {
    if (questions[[i]][["Payload"]][["QuestionType"]] == 
        "SBS") {
      split_questions <- list()
      for (j in 1:questions[[i]][["Payload"]][["NumberOfQuestions"]]) {
        split_questions[[j]] <- list()
        split_questions[[j]][["Payload"]] <- questions[[i]][["Payload"]][["AdditionalQuestions"]][[as.character(j)]]
        split_questions[[j]][["Payload"]][["QuestionText"]] <- paste0(clean_html(questions[[i]][["Payload"]][["QuestionText"]]), 
                                                                      "-", clean_html(questions[[i]][["Payload"]][["AdditionalQuestions"]][[as.character(j)]][["QuestionText"]]))
        split_questions[[j]][["qtNotes"]] <- list()
        if ("qtNotes" %in% names(questions[[i]])) 
          split_questions[[j]][["qtNotes"]] <- questions[[i]][["qtNotes"]]
        split_questions[[j]][["qtNotes"]] <- c(split_questions[[j]][["qtNotes"]], 
                                               "This question was split from a side-by-side question.")
      }
      orig_question_id <- questions[[i]][["Payload"]][["QuestionID"]]
      split_question_ids <- lapply(split_questions, function(x) x[["Payload"]][["QuestionID"]])
      split_block_elements <- lapply(split_question_ids, 
                                     function(x) list(Type = "Question", QuestionID = x))
      for (k in 1:length(blocks)) {
        if ("BlockElements" %in% names(blocks[[k]])) {
          for (j in 1:length(blocks[[k]][["BlockElements"]])) {
            block_elmt_question_id <- blocks[[k]][["BlockElements"]][[j]][["QuestionID"]]
            if (block_elmt_question_id == orig_question_id) {
              blocks[[k]][["BlockElements"]][[j]] <- NULL
              blocks[[k]][["BlockElements"]] <- append(blocks[[k]][["BlockElements"]], 
                                                       split_block_elements, after = (j - 1))
              break
            }
          }
        }
      }
      questions[[i]] <- NULL
      questions <- append(questions, value = split_questions, 
                          after = (i - 1))
    }
  }
  return(list(questions, blocks))
}
```
