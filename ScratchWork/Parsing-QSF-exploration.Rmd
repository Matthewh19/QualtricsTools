---
title: "QSF Parsing Exercise"
author: "Emma Morgan"
date: "2/24/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(QualtricsTools)
```

##Updating functions

This is a space where anything we functionalize new can be added to our environment so that we can work wiht and use it in the later steps.

###Revise extraction of user notes and inserting into questions.

Now we can functionalize how we are creating user notes. This should replace notes_from_survey. We will also want to update how we insert notes into questions above.

```{r note_text_from_survey}

note_text_from_survey <- function(survey) {
  #From the survey, keep elements that have user notes; these are identified from the list of survey elements
  #as those with Elements "NT"
  user_notes_text <- keep(survey[["SurveyElements"]], ~.x[["Element"]]=="NT") %>%
    #Now rename the user notes with their QID based on parent ID instead of the primary attribute
    set_names(map_chr(., ~ .x[["Payload"]][["ParentID"]])) %>%
    #From the notes block payload, pluck "Notes" element
    #Now we want to pull only the next for the user notes
    #But only if the element "Removed" is false
    #First keep only the "Notes" section within Payload, which has the information we need
    map(~ pluck(.x, "Payload","Notes")) %>%
    #only keep notes for which the "Removed" status is FALSE; these are notes that have not been deleted
    map(~ keep(.x, ~ !.x[["Removed"]])) %>%
    #Now we want to pluck only the messages, which is the text of the note
    map(~map(.x, ~pluck(.x,"Message"))) %>%
    map(~ flatten(.x)) %>%
    #Prepend each note with the "User note: " text tag
    map(~map(.x,~stringr::str_c("User note: ",.x)))
  return(user_notes_text)
}
```   

###Notes into Questions

Revise the function that appends a list of questions with the appropriate user notes

```{r insert_notes_into_questions_rv}

insert_notes_into_questions_rv <- function(questions, notes) {
  #For each question, first see if it has corresponding notes.
  #If it does, append the question list with element "qtNotes"
  questions_with_notes <- questions %>%
    purrr::modify_if(~.x[["PrimaryAttribute"]] %in% names(notes),
                     ~ append(.x, list("qtNotes"= pluck(notes,.x[["PrimaryAttribute"]]))))
  return(questions_with_notes)
}

```

## Parsing the QSF

This is an exploration of trying to improve the ways in which we parse the QSF for the QualtricsTools project. Emma will work on this as she is able. This is being done with a markdown document to try and get a little more familiar with markdown and make notes as I go along.

Start by loading the QSF and CSV from the sample survey as a test


```{r setpath}
qsf_sample <- here::here("ScratchWork","Sample_survey_edits", "Long_Exhaustive_Sample_Survey.qsf")
csv_sample <- here::here("data","Sample Surveys", "Long Exhaustive Sample Survey","Long_Exhaustive_Sample_Survey.csv")
```

The csv should not be necessary at this time and the goal is to do most things without it. To start, read in the QSF JSON and assign to variable "survey".

```{r readsurvey}
survey_json <- rjson::fromJSON(file=qsf_sample)
```

The function blocks_from_survey pulls the "Survey Blocks" element from the json file. This creates placeholders for all of the survey elements. This could be done using purrr instead of the Filter function. 

First step should be to go through and name each list item of survey elements based on the primary attribute. This will be much cleaner and easier to use since currently the items are unnamed. This should give us the QIDs for questions that we need, the information we need for Survey Blocks, Survey Flow, Survey Options, and the default response set.

The steps are not going to use pipes for now so everything is explicit, but this can be made much easier at a later time.

### Revise setup process using purrr and %>%

```{r revise-parse-qsf}
#goal to revise get_setup
#This is going to use the sample survey, but this could change.
#The survey JSON was read in during an early block, so we can just work with this.
#Extract the survey elements from survey
survey_elements <- survey_json[["SurveyElements"]] %>%
  # Name each item of survey elements based on the primary attribute.
  # This includes Survey Blocks, Survey Flow, Survey Options, and QIDs.
  # These names should make it much easier for us to get the information we need to extract.
  purrr::set_names(map_chr(., "PrimaryAttribute"))

qtNotesList <- note_text_from_survey(survey_json)

#Now extract the blocks; this is really the payload element of element "Survey Blocks"
#Replace blocks_from_survey
blocks_all <- purrr::pluck(survey_elements, "Survey Blocks", "Payload") %>%
  #Name the blocks with their descriptive value; this will be more user-friendly
  #Use "." to refer to the piped value within the map_chr function
  purrr::set_names(map_chr(.,"Description"))

trash_questions <- blocks_all %>%
  #Now pluck just the trash block
  pluck("Trash / Unused Questions", "BlockElements") %>%
  #Pull a character vector of only the QIDs for questions that are in the trash
  map_chr(.,"QuestionID")
  

blocks_notrash <- blocks_all %>%
  #Remove trash block based on the "Type" element of the block
  purrr::keep(~ .x[["Type"]]!= "Trash") %>%
  #Name the BlockElements (quesiton items) within the blocks
  map(~ modify_at(.x, "BlockElements", ~set_names(.x, map_chr(.x, ~ str_c(.x[["QuestionID"]],.x[["Type"]],sep="-")))))


#Now we want to extract the list of questions. These can be identified as SurveyElements that have Element "SQ"
#Replaces questions_from_survey
questions <- purrr::keep(survey_elements, ~ .x[["Element"]]=="SQ") %>%
  #Remove questions that are in the trash, as specified by "trash_questions
  discard( ~ .x[["PrimaryAttribute"]] %in% trash_questions) %>%
  #Now clean question text using clean_html
  map(~ append(.x,list("QuestionTextClean" = clean_html(.x[["Payload"]][["QuestionText"]])))) %>%
  #Add the Qualtrics question type; this is for reference and won't be used in results
  map(~append(.x, list("Qualtrics_qtype" = .x[["Payload"]][["QuestionType"]]))) %>%
  #Add human readable question type to each question; this can be edited if we want 
  #We will want ot expand this as we keep going
  #We will need to reclassify the question type when we split side-by-side!!
  map(~append(.x,list("QuestionTypeHuman" = dplyr::case_when(is_multiple_answer(.x) ~ "Multiple Answer",
                                                             is_single_answer(.x) ~ "Single Answer",
                                                             is_rank_order(.x) ~ "Rank Order",
                                                             is_text_entry(.x) ~ "Text Entry",
                                                             .x[["Qualtrics_qtype"]]=="SBS" ~ "Side-by-side",
                                                             .x[["Qualtrics_qtype"]]=="DB" ~ "Descriptive Box",
                                                             TRUE ~ "Other question type")))) %>%
  #Now we want to insert notes into questions.
  #Previously side-by-side questions were not getting their notes. 
  #This is now happening before the split to ensure that notes are included
  insert_notes_into_questions_rv(notes = qtNotesList)


##split side by side questions into their component questions

```

### User Notes

We need to update how we're thinking about user notes. These, too, should be easier to find! They should be labeled with the parent IDs (QIDs) so that we can easily link them to the appropriate quesitons.

```{r usernotes}

#First pull the notes from the survey elements
user_notes_full <- keep(survey_elements, ~ .x[["Element"]]=="NT") %>%
  #Now rename the user notes with their QID based on parent ID instead of the primary attribute
  set_names(map_chr(., ~ .x[["Payload"]][["ParentID"]]))

user_notes_text <- user_notes_full %>%
  #Now we want to pull only the next for the user notes
  #But only if the element "Removed" is false
  #First keep only the "Notes" section within Payload, which has the information we need
  map(~ pluck(.x, "Payload","Notes")) %>%
  #only keep notes for which the "Removed" status is FALSE; these are notes that have not been deleted
  map(~ keep(.x, ~ !.x[["Removed"]])) %>%
  #Now we want to pluck only the messages
  map(~map(.x, ~pluck(.x,"Message"))) %>%
  map(~ flatten(.x))

#This should end up with a list of user notes named by QID; these may have multiple elements if a question had more than one user note.

```

### Revise side-by-side split

At this point we have created one list of all the questions excluding the ones in the trash, and a second list with the blocks excluding the trash block. The next step in get_setup is to split the side-by-side questions. I'm going to explore to see if we can split these more efficiently and with human readable text instead of trying to use all of the complicated block indexing.

```{r split_sBS_new_1}

#Keep only the side-by-side questions for this exploration
sbs <- keep(questions, ~.x[["Payload"]][["QuestionType"]]=="SBS") 

#First step will be splitting a single question, then we can work on doing this for all and re-inserting to the list.

sbs_sample <- sbs[[1]]
  #Get just the Payload for each of these questions, since this is what we actually need

sbs_sample_split <- sbs_sample %>%
  #Pull only the payload
  pluck("Payload") 

#Pull out the additional information from these questions
addlq <- pluck(sbs_sample_split, "AdditionalQuestions") %>%
  #Add names based on the QID
  #There's an issue with the "#" symbol, so replace with underscore in the question name; may need to change this later
  set_names(map_chr(.,~ str_replace(.x[["QuestionID"]], "#","_"))) 


#Now we also want to pull the main question information without the additinal questions part
#Do use this using modify_at to remove the AdditionalQuestions list element by reassinging to NULL
mainq <- modify_at(sbs_sample_split, "AdditionalQuestions", ~NULL)

#Names of Main question elements:"
sort(names(mainq))

#Names of Additional Question elements:
sort(names(addlq[[1]]))

```

Now we have separated the side-by-side question into a main question part and the additional question parts. The goal now will be to identify what we need from the main question to be inserted into the additional questions.

```{r split_SBS_new_2}

#start with our first additional question.
#Update the Question Text to include both the text from the main question and the sbs component question
sbsq <- addlq[[1]]

#Main question text
mainq$QuestionText
#Additional question text
sbsq$QuestionText

#I'm going to create a TEMPORARY placeholder for how to combine the text with "---"
sbsq_new <- sbsq %>%
  #Create a new original question text that is the SBS component only
  list_modify("QuestionText_orig" = .[["QuestionText"]]) %>%
  list_modify("QuestionText" = str_c(mainq[["QuestionText"]],"---",.[["QuestionText_orig"]])) 
  #Insert Notes from the main question and additional note indicating split from side-by-side
  #To do this we first need to have questions...which we don't. This is going to have to be something that gets updated


```


### Creating response column dictionary from QSF

Now I want to try and create a response column dictionary. I'm going to go back to do this using the sample survey

```{r response_column_dictionary}

qsf_sample <- here::here("data","Sample Surveys", "Better Sample Survey","Better_Sample_Survey.qsf")
csv_sample <- here::here("data","Sample Surveys", "Better Sample Survey","Better_Sample_Survey.csv")

survey_json <- rjson::fromJSON(file=qsf_sample)
#Extract the survey elements from survey
survey_elements_unnamed <- survey_json[["SurveyElements"]]

survey_elements <-purrr::set_names(survey_elements_unnamed, map_chr(survey_elements_unnamed, "PrimaryAttribute"))
#Now I want to set up something from the Blocks with the list of questions and their corresponding Block

blocks_use <- survey_elements %>%
  pluck("Survey Blocks", "Payload") %>%
  set_names(map_chr(., "Description"))

#Now trying to make a data frame
qdict <- enframe(blocks_use, name = "Block Name", value = "BlockList") %>%
  #Now we want to expand the BlockList column
  unnest_wider(BlockList) %>%
  unnest_longer(BlockElements) %>%
  
  mutate(ElementType = map_chr(BlockElements, "Type"),
         QID = map_chr(BlockElements, "QuestionID"))

#Now we want to get the question information separately

question_dict <- survey_elements %>%
  keep(~ .x[["Element"]] == "SQ") %>%
  enframe(name = "QID", value = "QuestionList") %>%
  unnest_wider(QuestionList) %>%
  unnest_wider(Payload)

#At this point we have most of the information in a table. There are still lists for choices and recode values and 
#we will need to worry about check all that apply and such, but it is getting closer.



```

### get_setup

The get_setup function is our starting point for QualtricsTools. Understanding and simplifying this will help us to make a better tool and allow more flexibility moving forward.

```{r get_setup}
get_setup <-
  function (qsf_path,
            csv_path,
            headerrows,
            already_loaded,
            return_data_as_list = FALSE,
            sample_data = FALSE)
  {
    if (missing(already_loaded)) {
      already_loaded <- FALSE
    }
    if (already_loaded == FALSE && sample_data == FALSE) {
      if (missing(headerrows)) {
        headerrows <-
          readline(prompt = "Enter the number of response data header rows [Default: 3]: ")
        if (!grepl("^[0-9]+$", headerrows)) {
          cat("Defaulting to headerrows = 3\n")
          headerrows = 3
        }
        else
          headerrows <- as.integer(headerrows)
      }
      if (missing(qsf_path)) {
        survey <- ask_for_qsf()
      }
      else {
        survey <- ask_for_qsf(qsf_path)
      }
      if (missing(csv_path)) {
        capture.output(responses <- ask_for_csv(headerrows = headerrows))
      }
      else {
        capture.output(responses <- ask_for_csv(csv_path,
                                                headerrows = headerrows))
      }
      original_first_rows <- as.data.frame(responses[[2]])
      responses <- as.data.frame(responses[[1]])
    }
    if (already_loaded == TRUE && sample_data == FALSE) {
      if (exists("survey", where = globalenv()) && exists("responses",
                                                          where = globalenv()) && exists("original_first_rows",
                                                                                         where = globalenv())) {
        survey <- get("survey", envir = globalenv())
        responses <- get("responses", envir = globalenv())
        original_first_rows <- get("original_first_rows",
                                   envir = globalenv())
      }
      else
        stop(
          "\nThe necessary objects do not exist in the global scope. Each of survey,\nresponses, and original_first_rows should be in the global scope when\nusing the global scope when using the already_loaded=TRUE parameter.\nUse ask_for_qsf() and ask_for_csv() to get a survey object list from a\nQualtrics Survey File and a pair of dataframes (responses,\noriginal_first_rows) from a survey's CSV response data. Alternatively,\npass the parameters for qsf_path, csv_path, and headerrows, or use the\nsample_survey=TRUE parameter."
        )
    }
    if (sample_data == TRUE) {
      survey <- sample_survey
      responses <- sample_responses
      original_first_rows <- sample_original_first_rows
    }
    questions_and_blocks <-
      get_reorganized_questions_and_blocks(survey,
                                           responses, original_first_rows)
    questions <- questions_and_blocks[[1]]
    blocks <- questions_and_blocks[[2]]
    blocks[["header"]] <- c(paste0("Survey Name: ",
                                   survey[["SurveyEntry"]][["SurveyName"]]),
                            paste0("Number of Respondents: ", nrow(responses)))
    flow <- flow_from_survey(survey)
    if (return_data_as_list) {
      return_vals = list(
        survey = survey,
        responses = responses,
        questions = questions,
        blocks = blocks,
        original_first_rows = original_first_rows,
        flow = flow
      )
      return(return_vals)
    }
    else {
      survey <<- survey
      responses <<- responses
      questions <<- questions
      blocks <<- blocks
      original_first_rows <<- original_first_rows
      flow <<- flow_from_survey(survey)
      if (exists("survey", 1) && exists("responses",
                                        1) && exists("questions", 1) && exists("blocks",
                                                                               1) && exists("original_first_rows")) {
        cat(
          "survey, responses, questions, blocks, original_first_rows,\n        and flow have now been made global objects.\n"
        )
      }
    }
  }
```


### get_reorganized_questions_and_blocks

This is the function we are trying to simplify. In many ways, get_reorganized_questions_and_blocks is the starting workhorse upon which get_setup functions and orients a user to working with QualtricsTools.

```{r get_reorganized_questions_and_blocks}

get_reorganized_questions_and_blocks <-
  function(survey, responses, original_first_rows) {
    # select the block elements from the survey
    blocks <- blocks_from_survey(survey)

    # select the questions from the survey
    questions <- questions_from_survey(survey)

    # remove the questions that were found in the trash block
    questions <- remove_trash_questions(questions, blocks)

    # remove the trash block from the blocks
    blocks <- remove_trash_blocks(blocks)

    # split side by side questions into their component questions
    questions_and_blocks <- split_side_by_sides(questions, blocks)
    questions <- questions_and_blocks[[1]]
    blocks <- questions_and_blocks[[2]]

    # clean the question text of HTML and CSS tags
    questions <- clean_question_text(questions)

    # categorize each question's Response Type
    # (Single Answer, Multiple Answer,
    #  Text Entry, Rank Order)
    questions <- human_readable_qtype(questions)

    # insert the response columns into their corresponding
    # question under question[['Responses']]
    questions <-
      link_responses_to_questions(questions, responses, original_first_rows)

    # generate each question's results table and insert it
    # in question[['Table']]
    questions <- generate_results(questions, original_first_rows)

    # insert notes into their corresponding questions
    notes <- notes_from_survey(survey)
    questions <- insert_notes_into_questions(questions, notes)

    # insert the questions into the blocks
    blocks <- questions_into_blocks(questions, blocks)

    # insert the header into the blocks
    blocks[['header']] <- c(paste0("Survey Name: ",
                                   survey[['SurveyEntry']][['SurveyName']]),
                            paste0("Number of Respondents: ",
                                   nrow(responses)))

    # return questions and blocks as a list of 2 elements
    questions_and_blocks <- list()
    questions_and_blocks[['questions']] <- questions
    questions_and_blocks[['blocks']] <- blocks
    return(questions_and_blocks)
  }
```

Existing function for splitting side_by_side questions. This is for reference currently and should not be run as actual R script.

### split_side_by_sides

```{r split_side_by_sides}
#This is the existing code to create the function splitting side-by-side questions.
#It is included here for reference during the development/revision process.

split_side_by_sides <- function(questions, blocks)
{
  for (i in length(questions):1) {
    if (questions[[i]][["Payload"]][["QuestionType"]] == 
        "SBS") {
      split_questions <- list()
      for (j in 1:questions[[i]][["Payload"]][["NumberOfQuestions"]]) {
        split_questions[[j]] <- list()
        split_questions[[j]][["Payload"]] <- questions[[i]][["Payload"]][["AdditionalQuestions"]][[as.character(j)]]
        split_questions[[j]][["Payload"]][["QuestionText"]] <- paste0(clean_html(questions[[i]][["Payload"]][["QuestionText"]]), 
                                                                      "-", clean_html(questions[[i]][["Payload"]][["AdditionalQuestions"]][[as.character(j)]][["QuestionText"]]))
        split_questions[[j]][["qtNotes"]] <- list()
        if ("qtNotes" %in% names(questions[[i]])) 
          split_questions[[j]][["qtNotes"]] <- questions[[i]][["qtNotes"]]
        split_questions[[j]][["qtNotes"]] <- c(split_questions[[j]][["qtNotes"]], 
                                               "This question was split from a side-by-side question.")
      }
      orig_question_id <- questions[[i]][["Payload"]][["QuestionID"]]
      split_question_ids <- lapply(split_questions, function(x) x[["Payload"]][["QuestionID"]])
      split_block_elements <- lapply(split_question_ids, 
                                     function(x) list(Type = "Question", QuestionID = x))
      for (k in 1:length(blocks)) {
        if ("BlockElements" %in% names(blocks[[k]])) {
          for (j in 1:length(blocks[[k]][["BlockElements"]])) {
            block_elmt_question_id <- blocks[[k]][["BlockElements"]][[j]][["QuestionID"]]
            if (block_elmt_question_id == orig_question_id) {
              blocks[[k]][["BlockElements"]][[j]] <- NULL
              blocks[[k]][["BlockElements"]] <- append(blocks[[k]][["BlockElements"]], 
                                                       split_block_elements, after = (j - 1))
              break
            }
          }
        }
      }
      questions[[i]] <- NULL
      questions <- append(questions, value = split_questions, 
                          after = (i - 1))
    }
  }
  return(list(questions, blocks))
}
```
